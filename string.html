<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv=Content-Type content="text/html;charset=utf-8">
			<meta name="keywords" content="字符串,Python 学习笔记,Python教程">
		
			<meta name="description" content="正则表达式是处理字符串最重要的一种手段。正则函数re有几个重要的函数：match():匹配字符串开始位置。search(...">
		
	<meta http-equiv="Content-Language" content="zh-cn" />
	<meta content=always name=referrer>
	<link rel="stylesheet" href="stylesheets/page_article.min.333ba298.css">
<script src="stylesheets/jquery.min.js"></script>
<script src="stylesheets/page_article.min.f4e6f530.js"></script>
		<title>字符串 - Python 学习笔记</title>
	</head>
<body data-spy="scroll" data-target="#myScrollspy">
<div class="article-header">
	<div class="container article-container">
		<span class="title"><a href="">Python 学习笔记</a></span>
	</div>
</div>
<div class="container article-container">
	<div class="left fl " data-offset-top="300">
		<div class="left_title"><a class="" href="">刷新页面</a></div>
		<div class="left_line"></div>
		<div class="left_title">
		<p>第一部分 Python 语言</p>
		</div>
			<div class="left_name">
		<div class="left_title">
		<a class=""  href="basic-environment.html">基本环境</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="index.html">内置类型</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="expression.html">表达式</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="function.html">函数</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="iterator.html">迭代器</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="module.html">模块</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="class.html">类</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="abnormal.html">异常</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="decorator.html">装饰器</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="descriptor.html">描述符</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="metaclass.html">元类</a>
		</div>
				</div>
			<div class="left_line"></div>
		<div class="left_title">
		<p>第二部分 标准库</p>
		</div>
			<div class="left_name">
		<div class="left_title">
		<a class=" active "  href="string.html">字符串</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="data-type.html">数据类型</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="mathematical-operations.html">数学运算</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="files-and-directories.html">文件与目录</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="data-stored.html">数据存储</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="operating-system.html">操作系统</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="process-communication.html">进程通信</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="application-framework.html">程序框架</a>
		</div>
				</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="extended-library.html">第三部分 扩展库</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="appendix.html">附录</a>
		</div>
	</div>
	<div class="main fl">
		<div class="markdown-body"><h1>字符串</h1>
<h2 id="12eccbdd9b32918131341f38907cbbb5">re</h2>
<p>正则表达式是处理字符串最重要的一种手段。</p>
<p><img src="images/3E3E7EA044B352A401C2AC3CA1555C63.png" alt="" /></p>
<p><img src="images/2B4804534BCD14EEDD40E87C918D033F.png" alt="" /></p>
<p><strong>正则函数</strong></p>
<p>re 有几个重要的函数：</p>
<ul>
<li>match(): 匹配字符串开始位置。</li>
<li>search(): 扫描字符串，找到第一个位置。</li>
<li>findall(): 找到全部匹配，以列表返回。</li>
<li>finditer(): 找到全部匹配，以迭代器返回。</li>
</ul>
<p>match 和 search 仅匹配一次，匹配不到返回 None。</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = "12abc345ab"
&gt;&gt;&gt; m = re.match(r"\d+", s)
&gt;&gt;&gt; m.group(), m.span()
('12', (0, 2))
&gt;&gt;&gt; m = re.match(r"\d{3,}", s)
&gt;&gt;&gt; m is None
True
&gt;&gt;&gt; m = re.search(r"\d{3,}", s)
&gt;&gt;&gt; m.group(), m.span()
('345', (5, 8))
&gt;&gt;&gt; m = re.search(r"\d+", s)
&gt;&gt;&gt; m.group(), m.span()
('12', (0, 2))</code></pre>
<p>findall 返回列表 (或空列表)，finditer 和 match、search 一样返回 MatchObject 对象。</p>
<pre><code>&gt;&gt;&gt; ms = re.findall(r"\d+", s)
&gt;&gt;&gt; ms
['12', '345']
&gt;&gt;&gt; ms = re.findall(r"\d{5}", s)
&gt;&gt;&gt; ms
[]
&gt;&gt;&gt; for m in re.finditer(r"\d+", s): print m.group(), m.span()
...
12 (0, 2)
345 (5, 8)
&gt;&gt;&gt; for m in re.finditer(r"\d{5}", s): print m.group(), m.span() # 返回空列表
...
&gt;&gt;&gt;</code></pre>
<p><strong>MatchObject</strong></p>
<p>match、search、finditer 返回的对象 —— MatchObject。</p>
<ul>
<li>group(): 返回匹配的完整字符串。</li>
<li>start(): 匹配的开始位置。</li>
<li>end(): 匹配的结束位置。</li>
<li>span(): 包含起始、结束位置的元组。</li>
<li>groups(): 返回分组信息。</li>
<li>groupdict(): 返回命名分组信息。</li>
</ul>
<pre><code>&gt;&gt;&gt; m = re.match(r"(\d+)(P&lt;letter&gt;[abc]+)", s)
&gt;&gt;&gt; m.group()
'12abc'
&gt;&gt;&gt; m.start()
0
&gt;&gt;&gt; m.end()
5
&gt;&gt;&gt; m.span()
(0, 5)
&gt;&gt;&gt; m.groups()
('12', 'abc')
&gt;&gt;&gt; m.groupdict()
{'letter': 'abc'}</code></pre>
<p>group() 可以接收多个参数，用于返回指定序号的分组。</p>
<pre><code>&gt;&gt;&gt; m.group(0)
'12abc'
&gt;&gt;&gt; m.group(1)
'12'
&gt;&gt;&gt; m.group(2)
'abc'
&gt;&gt;&gt; m.group(1,2)
('12', 'abc')
&gt;&gt;&gt; m.group(0,1,2)
('12abc', '12', 'abc')</code></pre>
<p>start()、end() 和 span() 同样能接收分组序号。和 group() 一样，序号 0 表示整体匹配结果。</p>
<pre><code>&gt;&gt;&gt; m.start(0), m.end(0)
(0, 5)
&gt;&gt;&gt; m.start(1), m.end(1)
(0, 2)
&gt;&gt;&gt; m.start(2), m.end(2)
(2, 5)
&gt;&gt;&gt; m.span(0)
(0, 5)
&gt;&gt;&gt; m.span(1)
(0, 2)
&gt;&gt;&gt; m.span(2)
(2, 5)</code></pre>
<p><strong>编译标志</strong></p>
<p>可以用 re.I、re.M 等参数，也可以直接在表达式中添加 &quot;(iLmsux)&quot; 标志。</p>
<ul>
<li>s: 单行。&quot;.&quot; 匹配包括换行符在内的所有字符。</li>
<li>i: 忽略大小写。</li>
<li>L: 让 &quot;\w&quot; 能匹配当地字符，貌似对中文支持不好。</li>
<li>m: 多行。</li>
<li>x: 忽略多余的空白字符，让表达式更易阅读。</li>
<li>u: Unicode。</li>
</ul>
<p>试试看。</p>
<pre><code>&gt;&gt;&gt; re.findall(r"[a-z]+", "%123Abc%45xyz&amp;")
['bc', 'xyz']
&gt;&gt;&gt; re.findall(r"[a-z]+", "%123Abc%45xyz&amp;", re.I)
['Abc', 'xyz']
&gt;&gt;&gt; re.findall(r"(i)[a-z]+", "%123Abc%45xyz&amp;")
['Abc', 'xyz']</code></pre>
<p>下面这么写好看多了吧？</p>
<pre><code>&gt;&gt;&gt; pattern = r"""
...     (\d+) # number
...     ([a-z]+) # letter
... """
&gt;&gt;&gt; re.findall(pattern, "%123Abc\n%45xyz&amp;", re.I | re.S | re.X)
[('123', 'Abc'), ('45', 'xyz')]</code></pre>
<p><strong>组操作</strong></p>
<p>命名组：(P<name>...)</p>
<pre><code>&gt;&gt;&gt; for m in re.finditer(r"(P&lt;number&gt;\d+)(P&lt;letter&gt;[a-z]+)", "%123Abc%45xyz&amp;", re.I):
...     print m.groupdict()
...
{'number': '123', 'letter': 'Abc'}
{'number': '45', 'letter': 'xyz'}</code></pre>
<p>无捕获组：(:...)，作为匹配条件，但不返回。</p>
<pre><code>&gt;&gt;&gt; for m in re.finditer(r"(:\d+)([a-z]+)", "%123Abc%45xyz&amp;", re.I):
...     print m.groups()
...
('Abc',)
('xyz',)</code></pre>
<p>反向引用：\<number> 或 (P=name)，引用前面的组。</p>
<pre><code>&gt;&gt;&gt; for m in re.finditer(r"&lt;a&gt;\w+&lt;/a&gt;", "%&lt;a&gt;123Abc&lt;/a&gt;%&lt;b&gt;45xyz&lt;/b&gt;&amp;"):
...     print m.group()
...
&lt;a&gt;123Abc&lt;/a&gt;
&gt;&gt;&gt; for m in re.finditer(r"&lt;(\w)&gt;\w+&lt;/(\1)&gt;", "%&lt;a&gt;123Abc&lt;/a&gt;%&lt;b&gt;45xyz&lt;/b&gt;&amp;"):
...     print m.group()
...
&lt;a&gt;123Abc&lt;/a&gt;
&lt;b&gt;45xyz&lt;/b&gt;
&gt;&gt;&gt; for m in re.finditer(r"&lt;(P&lt;tag&gt;\w)&gt;\w+&lt;/(P=tag)&gt;", "%&lt;a&gt;123Abc&lt;/a&gt;%&lt;b&gt;45xyz&lt;/
b&gt;&amp;"):
...     print m.group()
...
&lt;a&gt;123Abc&lt;/a&gt;
&lt;b&gt;45xyz&lt;/b&gt;</code></pre>
<p>正声明 (=...)：组内容必须出现在右侧，不返回。
负声明 (...)：组内容不能出现在右侧，不返回。
反向正声明 (&lt;=)：组内容必须出现在左侧，不返回。
反向负声明 (&lt;)：组内容不能出现在左侧，不返回。</p>
<pre><code>&gt;&gt;&gt; for m in re.finditer(r"\d+(=[ab])", "%123Abc%45xyz%780b&amp;", re.I):
...     print m.group()
...
123
780
&gt;&gt;&gt; for m in re.finditer(r"(&lt;\d)[a-z]{3,}", "%123Abc%45xyz%byse&amp;", re.I):
... print m.group()
...
byse</code></pre>
<p>更多信息请阅读官方文档或更专业的书籍。</p>
<p><strong>修改</strong></p>
<p>split: 用 pattern 做分隔符切割字符串。如果用 &quot;(pattern)&quot;，那么分隔符也会返回。</p>
<pre><code>&gt;&gt;&gt; re.split(r"\W", "abc,123,x")
['abc', '123', 'x']
&gt;&gt;&gt; re.split(r"(\W)", "abc,123,x")
['abc', ',', '123', ',', 'x']</code></pre>
<p>sub: 替换子串。可指定替换次数。</p>
<pre><code>&gt;&gt;&gt; re.sub(r"[a-z]+", "*", "abc,123,x")
'*,123,*'
&gt;&gt;&gt; re.sub(r"[a-z]+", "*", "abc,123,x", 1)
'*,123,x'</code></pre>
<p>subn() 和 sub() 差不多，不过返回 &quot;(新字符串，替换次数)&quot;。</p>
<pre><code>&gt;&gt;&gt; re.subn(r"[a-z]+", "*", "abc,123,x")
('*,123,*', 2)</code></pre>
<p>还可以将替换字符串改成函数，以便替换成不同的结果。</p>
<pre><code>&gt;&gt;&gt; def repl(m):
...     print m.group()
...     return "*" * len(m.group())
...
&gt;&gt;&gt; re.subn(r"[a-z]+", repl, "abc,123,x")
abc
x
('***,123,*', 2)</code></pre>
<h2 id="a9004d1643296cc67b6872e47f3724cc">StringIO</h2>
<p>提供类文件接口的字符串缓冲区，可选用性能更好的 cStringIO 版本。</p>
<pre><code>&gt;&gt;&gt; from contextlib import closing
&gt;&gt;&gt; from cStringIO import StringIO
&gt;&gt;&gt; with closing(StringIO("ab")) as f:
...     print &gt;&gt; f, "cd"
...     f.write("1234")
...     print f.getvalue()
abcd
1234</code></pre>
<p>建议用 with 上下文确保调用 close() 方法释放所占用内存。用 getvalue() 返回字符串前，必须确保是打开状态 (closed = False)。</p>
<h2 id="0f8d6fb56fe6cdf55ad0114ec5b51dbb">struct</h2>
<p>struct 看上去有点像 format，区别是它输出的是二进制字节序列。可以通过格式化参数，指定类型、长度、字节序(大小端)、内存对齐等。</p>
<pre><code>&gt;&gt;&gt; from struct import *
&gt;&gt;&gt; hexstr = lambda s: map(lambda c: hex(ord(c)), s)
&gt;&gt;&gt; s = pack("i", 0x1234)
&gt;&gt;&gt; hexstr(s)      # 4 字节整数小端排列
['0x34', '0x12', '0x0', '0x0']
&gt;&gt;&gt; unpack("i", s)      # 还原。4660 = 0x1234
(4660,)
&gt;&gt;&gt; s = pack("&gt;i", 0x1234)    # 大端
&gt;&gt;&gt; hexstr(s)
['0x0', '0x0', '0x12', '0x34']
&gt;&gt;&gt; s = pack("2i2s", 0x12, 0x34, "ab")   # 多值。注意指定字符串长度。
&gt;&gt;&gt; hexstr(s)
['0x12', '0x0', '0x0', '0x0', '0x34', '0x0', '0x0', '0x0', '0x61', '0x62']
&gt;&gt;&gt; unpack("2i2s", s)
(18, 52, 'ab')</code></pre>
<p>还可以将结果输出到 bytearray、array、ctypes.create_str_buffer() 等缓冲对象中。</p>
<pre><code>
&gt;&gt;&gt; fmt = "3bi2s"
&gt;&gt;&gt; size = calcsize(fmt)   # 计算指定格式转换所需的字节长度。
&gt;&gt;&gt; buffer = bytearray(size)
&gt;&gt;&gt; pack_into(fmt, buffer, 0, 0x1, 0x2, 0x3, 0x1FFFFF, "ab")
&gt;&gt;&gt; buffer
bytearray(b'\x01\x02\x03\x00\xff\xff\x1f\x00ab')
&gt;&gt;&gt; unpack_from(fmt, str(buffer), 0)
(1, 2, 3, 2097151, 'ab')</code></pre></div>
		<div class="previous-and-next">
						<span class="pull-left">上一篇: <a id="previous_link" href="metaclass.html" data-toggle="tooltip" data-placement="top" title="上翻页快捷键：左方向键">元类</a></span>
			
						<span class="pull-right">下一篇: <a id="next_link" href="data-type.html" data-toggle="tooltip" data-placement="top" title="下翻页快捷键：右方向键">数据类型</a></span>
					</div>
				<div id="jkcomments"></div>
			</div>
	<div class="wiki-right fl">
		<div id="myScrollspy">
						<ul class="nav nav-tabs nav-stacked" data-spy="affix" data-offset-top="300">
							<li><a href="#12eccbdd9b32918131341f38907cbbb5">re</a></li>
							<li><a href="#a9004d1643296cc67b6872e47f3724cc">StringIO</a></li>
							<li><a href="#0f8d6fb56fe6cdf55ad0114ec5b51dbb">struct</a></li>
						</ul>
					</div>
		<div class="backtotop">
			<a href="javascript:;" class="btn-backtotop" style="display: none;"><div class="arrow"></div><div class="stick"></div></a>
		</div>
	</div>
	<div style="clear:both;"></div>
</div>
</body>
</html>