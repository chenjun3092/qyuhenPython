<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv=Content-Type content="text/html;charset=utf-8">
			<meta name="keywords" content="内置类型,Python 学习笔记,Python教程">
		
			<meta name="description" content="按照用途不同，Python内置类型可分为&quot;数据&quot;和&quot;程序&quot;两大类。数据类型：空值...">
		
	<meta http-equiv="Content-Language" content="zh-cn" />
	<meta content=always name=referrer>
	<link rel="stylesheet" href="stylesheets/page_article.min.333ba298.css">
<script src="stylesheets/jquery.min.js"></script>
<script src="stylesheets/page_article.min.f4e6f530.js"></script>
		<title>内置类型 - Python 学习笔记</title>
	</head>
<body data-spy="scroll" data-target="#myScrollspy">
<div class="article-header">
	<div class="container article-container">
		<span class="title"><a href="">Python 学习笔记</a></span>
	</div>
</div>
<div class="container article-container">
	<div class="left fl " data-offset-top="300">
		<div class="left_title"><a class="" href="">刷新页面</a></div>
		<div class="left_line"></div>
		<div class="left_title">
		<p>第一部分 Python 语言</p>
		</div>
			<div class="left_name">
		<div class="left_title">
		<a class=""  href="basic-environment.html">基本环境</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=" active "  href="index.html">内置类型</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="expression.html">表达式</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="function.html">函数</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="iterator.html">迭代器</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="module.html">模块</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="class.html">类</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="abnormal.html">异常</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="decorator.html">装饰器</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="descriptor.html">描述符</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="metaclass.html">元类</a>
		</div>
				</div>
			<div class="left_line"></div>
		<div class="left_title">
		<p>第二部分 标准库</p>
		</div>
			<div class="left_name">
		<div class="left_title">
		<a class=""  href="string.html">字符串</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="data-type.html">数据类型</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="mathematical-operations.html">数学运算</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="files-and-directories.html">文件与目录</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="data-stored.html">数据存储</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="operating-system.html">操作系统</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="process-communication.html">进程通信</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="application-framework.html">程序框架</a>
		</div>
				</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="extended-library.html">第三部分 扩展库</a>
		</div>
			<div class="left_line"></div>
		<div class="left_title">
		<a class=""  href="appendix.html">附录</a>
		</div>
	</div>
	<div class="main fl">
		<div class="markdown-body"><h1>内置类型</h1>
<p>按照用途不同，Python 内置类型可分为 &quot;数据&quot; 和 &quot;程序&quot; 两大类。</p>
<p>数据类型：</p>
<ul>
<li>空值: None</li>
<li>数字: bool, int, long, float, complex</li>
<li>序列: str, unicode, list, tuple</li>
<li>字典: dict</li>
<li>集合: set, frozenset</li>
</ul>
<h2 id="55d4790c5d819cd0462cbe89561b0dd4">数字</h2>
<p><strong>bool</strong></p>
<p>None、0、空字符串、以及没有元素的容器对象都可视为 False，反之为 True。</p>
<pre><code>&gt;&gt;&gt; map(bool, [None, 0, "", u"", list(), tuple(), dict(), set(), frozenset()])
[False, False, False, False, False, False, False, False, False]</code></pre>
<p>虽然有点古怪，但 True、False 的确可以当数字使用。</p>
<pre><code>&gt;&gt;&gt; int(True)
1
&gt;&gt;&gt; int(False)
0
&gt;&gt;&gt; range(10)[True]
1
&gt;&gt;&gt; x = 5
&gt;&gt;&gt; range(10)[x &gt; 3]
1</code></pre>
<p><strong>int</strong></p>
<p>在 64 位平台上，int 类型是 64 位整数 (sys.maxint)，这显然能应对绝大多数情况。整数是虚拟机特殊照顾对象：</p>
<ul>
<li>从堆上按需申请名为 PyIntBlock 的缓存区域存储整数对象。</li>
<li>使用固定数组缓存 [-5, 257) 之间的小数字，只需计算下标就能获得指针。</li>
<li>PyIntBlock 内存不会返还给操作系统，直至进程结束。</li>
</ul>
<p>看看 &quot;小数字&quot; 和 &quot;大数字&quot; 的区别：</p>
<pre><code>&gt;&gt;&gt; a = 15
&gt;&gt;&gt; b = 15
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; sys.getrefcount(a)
47
&gt;&gt;&gt; a = 257
&gt;&gt;&gt; b = 257
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; sys.getrefcount(a)
2</code></pre>
<p>因 PyIntBlock 内存只复用不回收，同时持有大量整数对象将导致内存暴涨，且不会在这些对象被回收后释放内存，造成事实上的内存泄露。</p>
<p>用 range 创建一个巨大的数字列表，这就需要足够多的 PyIntBlock 为数字对象提供存储空间。但换成 xrange 就不同了，每次迭代后，数字对象被回收，其占用内存空闲出来并被复用，内存也就不会暴涨了。</p>
<p>运行下面测试代码前，必须先安装 psutil 包，用来获取内存统计数据。</p>
<pre><code>$ sudo easy_install -U psutil</code></pre>
<pre><code>$ cat test.py
#/usr/bin/env python
import gc, os, psutil
def test():
    x = 0
    for i in range(10000000): # xrange
        x += i
    return x
def main():
    print test()
    gc.collect()
    p = psutil.Process(os.getpid())
    print p.get_memory_info()
if __name__ == "__main__":
    main()</code></pre>
<p>对比 range 和 xrange 所需的 RSS 值。</p>
<pre><code>range: meminfo(rss=93339648L, vms=2583552000L) # 89 MB
xrange: meminfo(rss=8638464L, vms=2499342336L) # 8 MB</code></pre>
<p>在实际开发中，很少会遇到这样的情形。就算是海量整数去重、排序，我们也可用位图等算法来节约内存使用。Python 3 已经用 xrange 替换掉了默认的 range，我们使用 2.x 时稍微注意一下即可。</p>
<p><strong>long</strong></p>
<p>当超出 int 限制时， 会自动转换成 long。 作为变长对象，只要有内存足够，足以存储无法想象的天文数字。</p>
<pre><code>&gt;&gt;&gt; a = sys.maxint
&gt;&gt;&gt; type(a)
&lt;type 'int'&gt;
&gt;&gt;&gt; b = a + 1   # 超出，自动使用 long 类型。
&gt;&gt;&gt; type(b)
&lt;type 'long'&gt;
&gt;&gt;&gt; 1 &lt;&lt; 3000
12302319221611....890612250135171889174899079911291512399773872178519018229989376L
&gt;&gt;&gt; sys.getsizeof(1 &lt;&lt; 0xFFFFFFFF)
572662332</code></pre>
<p>使用 long 的机会不多，Python 也就没有必要专门为其设计优化策略。</p>
<p><strong>float</strong></p>
<p>使用双精度浮点数 (float)，不能 &quot;精确&quot; 表示某些十进制的小数值。尤其是 &quot;四舍五入 (round)&quot; 的结果，可能和预想不同。</p>
<pre><code>&gt;&gt;&gt; 3 / 2   # 除法默认返回整数，在 Python 3 中返回浮点数。
1
&gt;&gt;&gt; float(3) / 2
1.5
&gt;&gt;&gt; 3 * 0.1 == 0.3  # 这个容易导致莫名其妙的错误。
False
&gt;&gt;&gt; round(2.675, 2) # 并没有想象中的四舍五入。
2.67</code></pre>
<p>如果需要，可用 Decimal 代替，它能精确控制运算精度、有效数位和 round 的结果。</p>
<pre><code>&gt;&gt;&gt; from decimal import Decimal, ROUND_UP, ROUND_DOWN
&gt;&gt;&gt; float('0.1') * 3 == float('0.3')     # float 转型精度不同
False
&gt;&gt;&gt; Decimal('0.1') * 3 == Decimal('0.3')    # decimal 没有问题
True
&gt;&gt;&gt; Decimal('2.675').quantize(Decimal('.01'), ROUND_UP)  # 精确控制 round
Decimal('2.68')
&gt;&gt;&gt; Decimal('2.675').quantize(Decimal('.01'), ROUND_DOWN)
Decimal('2.67')</code></pre>
<p>在内存管理上，float 也采用 PyFloatBlock 模式，但没有特殊的 &quot;小浮点数&quot;。</p>
<h2 id="cc4dd1da7e1a754534215f02fb9ba85d">字符串</h2>
<p>与字符串相关的问题总是很多，比如池化 (intern)、编码 (encode) 等。字符串是不可变类型，保存字符序列或二进制数据。</p>
<ul>
<li>短字符串存储在 arena 区域， str、unicode 单字符会被永久缓存。</li>
<li>str 没有缓存机制，unicode 则保留 1024 个宽字符长度小于 9 的复用对象。</li>
<li>内部包含 hash 值，str 另有标记用来判断是否被池化。</li>
</ul>
<p>字符串常量定义简单自由，可以是单引号、双引号或三引号。但我个人建议用双引号表示字符串，用单引号表示字符，和其他语言习惯保持一致。</p>
<pre><code>&gt;&gt;&gt; "It's a book."    # 双引号里面可以用单引号。
"It's a book."
&gt;&gt;&gt; 'It\'s a book.'   # 转义
"It's a book."
&gt;&gt;&gt; '{"name":"Tom"}'   # 单引号里面正常使用双引号。
'{"name":"Tom"}'
&gt;&gt;&gt; """     # 多行
... line 1
... line 2
... """
&gt;&gt;&gt; r"abc\x"    # r 前缀定义非转义的 raw-string。
'abc\\x'
&gt;&gt;&gt; "a" "b" "c"    # 自动合并多个相邻字符串。
'abc'
&gt;&gt;&gt; "中国人"     # UTF-8 字符串 (Linux 系统默认)。
'\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba'
&gt;&gt;&gt; type(s), len(s)
&lt;type 'str'&gt;, 9
&gt;&gt;&gt; u"中国人"    # 使用 u 前缀定义 UNICODE 字符串。
u'\u4e2d\u56fd\u4eba'
&gt;&gt;&gt; type(u), len(u)
&lt;type 'unicode'&gt;, 3</code></pre>
<p>基本操作：</p>
<pre><code>&gt;&gt;&gt; "a" + "b"
'ab'
&gt;&gt;&gt; "a" * 3
'aaa'
&gt;&gt;&gt; ",".join(["a", "b", "c"])     # 合并多个字符串。
'a,b,c'
&gt;&gt;&gt; "a,b,c".split(",")      # 按指定字符分割。
['a', 'b', 'c']
&gt;&gt;&gt; "a\nb\r\nc".splitlines()     # 按行分割。
['a', 'b', 'c']
&gt;&gt;&gt; "a\nb\r\nc".splitlines(True)    # 分割后，保留换行符。
['a\n', 'b\r\n', 'c']
&gt;&gt;&gt; "abc".startswith("ab"), "abc".endswith("bc")  # 判断是否以特定子串开始或结束。
True, True
&gt;&gt;&gt; "abc".upper(), "Abc".lower()    # 大小写转换。
'ABC', 'abc'
&gt;&gt;&gt; "abcabc".find("bc"), "abcabc".find("bc", 2)  # 可指定查找起始结束位置。
1, 4
&gt;&gt;&gt; " abc".lstrip(), "abc ".rstrip(), " abc ".strip() # 剔除前后空格。
'abc', 'abc', 'abc'
&gt;&gt;&gt; "abc".strip("ac")      # 可删除指定的前后缀字符。
'b'
&gt;&gt;&gt; "abcabc".replace("bc", "BC")    # 可指定替换次数。
'aBCaBC'
&gt;&gt;&gt; "a\tbc".expandtabs(4)     # 将 tab 替换成空格。
'a bc'
&gt;&gt;&gt; "123".ljust(5, '0'), "456".rjust(5, '0'), "abc".center(10, '*') # 填充
'12300', '00456', '***abc****'
&gt;&gt;&gt; "123".zfill(6), "123456".zfill(4)      # 数字填充
'000123', '123456'</code></pre>
<p><strong>编码</strong></p>
<p>Python 2.x 默认采用 ASCII 编码。为了完成编码转换，必须和操作系统字符编码统一起来。</p>
<pre><code>&gt;&gt;&gt; import sys, locale
&gt;&gt;&gt; sys.getdefaultencoding()  # Python 默认编码。
'ascii'
&gt;&gt;&gt; c = locale.getdefaultlocale(); c # 获取当前系统编码。
('zh_CN', 'UTF-8')
&gt;&gt;&gt; reload(sys)    # setdefaultencoding 在被初始化时被 site.py 删掉了。
&lt;module 'sys' (built-in)&gt;
&gt;&gt;&gt; sys.setdefaultencoding(c[1]) # 重新设置默认编码。</code></pre>
<p>str、unicode 都提供了 encode 和 decode 编码转换方法。</p>
<ul>
<li>encode: 将默认编码转换为其他编码。</li>
<li>decode: 将默认或者指定编码字符串转换为 unicode。</li>
</ul>
<pre><code>&gt;&gt;&gt; s = "中国人"; s
'\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba'
&gt;&gt;&gt; u = s.decode(); u   # UTF-8 -&gt; UNICODE
u'\u4e2d\u56fd\u4eba'
&gt;&gt;&gt; gb = s.encode("gb2312"); gb  # UTF-8 -&gt; GB2312
'\xd6\xd0\xb9\xfa\xc8\xcb'
&gt;&gt;&gt; gb.encode("utf-8")   # encode 会把 gb 当做默认 UTF-8 编码，所以出错。
UnicodeDecodeError: 'utf8' codec can't decode byte 0xd6 in position 0: invalid
continuation byte
&gt;&gt;&gt; gb.decode("gb2312")   # 可以将其转换成 UNICODE。
u'\u4e2d\u56fd\u4eba'
&gt;&gt;&gt; gb.decode("gb2312").encode() # 然后再转换成 UTF-8
'\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba'
&gt;&gt;&gt; unicode(gb, "gb2312")  # GB2312 -&gt; UNICODE
u'\u4e2d\u56fd\u4eba'
&gt;&gt;&gt; u.encode()    # UNICODE -&gt; UTF-8
'\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba'
&gt;&gt;&gt; u.encode("gb2312")   # UNICODE -&gt; GB2312
'\xd6\xd0\xb9\xfa\xc8\xcb'</code></pre>
<p>标准库另有 codecs 模块用来处理更复杂的编码转换，比如大小端和 BOM。</p>
<pre><code>&gt;&gt;&gt; from codecs import BOM_UTF32_LE
&gt;&gt;&gt; s = "中国人"
&gt;&gt;&gt; s
'\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba'
&gt;&gt;&gt; s.encode("utf-32")
'\xff\xfe\x00\x00-N\x00\x00\xfdV\x00\x00\xbaN\x00\x00'
&gt;&gt;&gt; BOM_UTF32_LE
'\xff\xfe\x00\x00'
&gt;&gt;&gt; s.encode("utf-32").decode("utf-32")
u'\u4e2d\u56fd\u4eba'</code></pre>
<p><strong>格式化</strong></p>
<p>Python 提供了两种字符串格式化方法，除了熟悉的 C 样式外，还有更强大的 format。</p>
<pre><code>%[(key)][flags][width][.precision]typecode</code></pre>
<p>标记：- 左对齐，+ 数字符号，# 进制前缀，或者用空格、0 填充。</p>
<pre><code>&gt;&gt;&gt; "%(key)s=%(value)d" % dict(key = "a", value = 10)  # key
'a=10'
&gt;&gt;&gt; "[%-10s]" % "a"      # 左对齐
'[a ]'
&gt;&gt;&gt; "%+d, %+d" % (-10, 10)     # 数字符号
'-10, +10'
&gt;&gt;&gt; "%010d" % 3       # 填充
'0000000003'
&gt;&gt;&gt; "%.2f" % 0.1234      # 小数位
'0.12'
&gt;&gt;&gt; "%#x, %#X" % (100, 200)     # 十六进制、前缀、大小写。
'0x64, 0XC8'
&gt;&gt;&gt; "%s, %r" % (m, m)      # s: str(); r: repr()
'test..., &lt;__main__.M object at 0x103c4aa10&gt;'</code></pre>
<p>format 方法支持更多的数据类型，包括列表、字典、对象成员等。</p>
<pre><code>{fieldconvertflag:formatspec}</code></pre>
<p>格式化规范：</p>
<pre><code>formatspec: [[fill]align][sign][#][0][width][.precision][typecode]</code></pre>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; "{key}={value}".format(key="a", value=10) # 使用命名参数。
'a=10'
&gt;&gt;&gt; "{0},{1},{0}".format(1, 2)    # field 可多次使用。
'1,2,1'
&gt;&gt;&gt; "{0:,}".format(1234567)    # 千分位符号
'1,234,567'
&gt;&gt;&gt; "{0:,.2f}".format(12345.6789)   # 千分位，带小数位。
'12,345.68'
&gt;&gt;&gt; "[{0:&lt;10}], [{0:^10}], [{0:*&gt;10}]".format("a") # 左中右对齐，可指定填充字符。
'[a ], [ a ], [*********a]'
&gt;&gt;&gt; import sys
&gt;&gt;&gt; "{0.platform}".format(sys)    # 成员
'darwin'
&gt;&gt;&gt; "{0[a]}".format(dict(a=10, b=20))   # 字典
'10'
&gt;&gt;&gt; "{0[5]}".format(range(10))    # 列表
'5'</code></pre>
<p>另有 string.Template 模板可供使用。该模块还定义了各种常见的字符序列。</p>
<pre><code>&gt;&gt;&gt; from string import letters, digits, Template
&gt;&gt;&gt; letters         # 字母表
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
&gt;&gt;&gt; digits         # 数字表
'0123456789'
&gt;&gt;&gt; Template("$name, $age").substitute(name = "User1", age = 20) # 模板替换。
'User1, 20'
&gt;&gt;&gt; Template("${name}, $age").safe_substitute(name = "User1")  # 没找到值，不会抛出异常。
'User1, $age'</code></pre>
<p><strong>池化</strong></p>
<p>在 Python 进程中，无数的对象拥有一堆类似 &quot;<strong>name</strong>&quot;、&quot;<strong>doc</strong>&quot; 这样的名字，池化有助于减少对象数量和内存消耗， 提升性能。</p>
<p>用 intern() 函数可以把运行期动态生成的字符串池化。</p>
<pre><code>&gt;&gt;&gt; s = "".join(["a", "b", "c"])
&gt;&gt;&gt; s is "abc"   # 显然动态生成的字符串 s 没有被池化。
False
&gt;&gt;&gt; intern(s) is "abc"  # intern 会检查内部标记。
True
&gt;&gt;&gt; intern(s) is intern(s) # 以后用 intern 从池中获取字符串对象，就可以复用了。
True</code></pre>
<p>当池化的字符串不再有引用时，将被回收。</p>
<h2 id="3712972d84adf48acbd6ad24b4d75ad0">列表</h2>
<p>从功能上看，列表 (list) 类似 Vector，而非数组或链表。</p>
<ul>
<li>列表对象和存储元素指针的数组是分开的两块内存，后者在堆上分配。</li>
<li>虚拟机会保留 80 个列表复用对象，但其元素指针数组会被释放。</li>
<li>列表会动态调整指针数组大小，预分配内存多于实际元素数量。</li>
</ul>
<p>创建列表：</p>
<pre><code>&gt;&gt;&gt; []       # 空列表。
[]
&gt;&gt;&gt; ['a', 'b'] * 3      # 这个少见吧。
['a', 'b', 'a', 'b', 'a', 'b']
&gt;&gt;&gt; ['a', 'b'] + ['c', 'd']    # 连接多个列表。
['a', 'b', 'c', 'd']
&gt;&gt;&gt; list("abcd")      # 将序列类型或迭代器转换为列表。
['a', 'b', 'c', 'd']
&gt;&gt;&gt; [x for x in range(3)]    # 生成器表达式。
[0, 1, 2]</code></pre>
<p>常见操作：</p>
<pre><code>&gt;&gt;&gt; l = list("abc")
&gt;&gt;&gt; l[1] = 2      # 按序号读写。
&gt;&gt;&gt; l       
['a', 2, 'c']
&gt;&gt;&gt; l = list(xrange(10))
&gt;&gt;&gt; l[2:-2]       # 切片。
[2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; l = list("abcabc")
&gt;&gt;&gt; l.count("b")      # 统计元素项。
2
&gt;&gt;&gt; l = list("abcabc")
&gt;&gt;&gt; l.index("a", 2)     # 从指定位置查找项，返回序号。
3
&gt;&gt;&gt; l = list("abc")
&gt;&gt;&gt; l.append("d")
&gt;&gt;&gt; l        # 追加元素。
['a', 'b', 'c', 'd']
&gt;&gt;&gt; l = list("abc")
&gt;&gt;&gt; l.insert(1, 100)     # 在指定位置插入元素。
&gt;&gt;&gt; l 
['a', 100, 'b', 'c']
&gt;&gt;&gt; l = list("abc")
&gt;&gt;&gt; l.extend(range(3))     # 合并列表。
&gt;&gt;&gt; l 
['a', 'b', 'c', 0, 1, 2]
&gt;&gt;&gt; l = list("abcabc")
&gt;&gt;&gt; l.remove("b")      # 移除第一个指定元素。
&gt;&gt;&gt; l 
['a', 'c', 'a', 'b', 'c']
&gt;&gt;&gt; l = list("abc")
&gt;&gt;&gt; l.pop(1)      # 弹出指定位置的元素 (默认最后项)。
'b'
&gt;&gt;&gt; l   
['a', 'c']</code></pre>
<p>可用 bisect 向有序列表中插入元素。</p>
<pre><code>&gt;&gt;&gt; import bisect
&gt;&gt;&gt; l = ["a", "d", "c", "e"]
&gt;&gt;&gt; l.sort()
&gt;&gt;&gt; l
['a', 'c', 'd', 'e']
&gt;&gt;&gt; bisect.insort(l, "b")
&gt;&gt;&gt; l
['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; bisect.insort(l, "d")
&gt;&gt;&gt; l
['a', 'b', 'c', 'd', 'd', 'e']</code></pre>
<p><strong>性能</strong></p>
<p>列表用 realloc() 调整指针数组内存大小，可能需要复制数据。插入和删除操作，还会循环移动后续元素。这些都是潜在的性能隐患。对于频繁增删元素的大型列表，应该考虑用链表等数据结构代替。</p>
<p>下面的例子测试了两种创建列表对象方式的性能差异。为获得更好测试结果，我们关掉 GC，元素使用同一个小整数对象，减少其他干扰因素。</p>
<pre><code>&gt;&gt;&gt; import itertools, gc
&gt;&gt;&gt; gc.disable()
&gt;&gt;&gt; def test(n):
...     return len([0 for i in xrange(n)])  # 先创建列表，然后 append。
&gt;&gt;&gt; def test2(n):
...     return len(list(itertools.repeat(0, n))) # 按照迭代器创建列表对象，一次分配内存。
&gt;&gt;&gt; timeit test(10000)
1000 loops, best of 3: 810 us per loop
&gt;&gt;&gt; timeit test2(10000)
10000 loops, best of 3: 89.5 us per loop</code></pre>
<p>从测试结果来看，性能差异非常大。</p>
<p>某些时候，可以考虑用数组代替列表。 和列表存储对象指针不同，数组直接内嵌数据，既省了创建对象的内存开销，又提升了读写效率。</p>
<pre><code>&gt;&gt;&gt; import array
&gt;&gt;&gt; a = array.array("l", range(10))  # 用其他序列类型初始化数组。
&gt;&gt;&gt; a
array('l', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; a.tolist()     # 转换为列表。
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; a = array.array("c")    # 创建特定类型数组。
&gt;&gt;&gt; a.fromstring("abc")    # 从字符串添加元素。
&gt;&gt;&gt; a
array('c', 'abc')
&gt;&gt;&gt; a.fromlist(list("def"))   # 从列表添加元素。
&gt;&gt;&gt; a
array('c', 'abcdef')
&gt;&gt;&gt; a.extend(array.array("c", "xyz"))  # 合并列表或数组。
&gt;&gt;&gt; a
array('c', 'abcdefxyz')</code></pre>
<h2 id="cda9f200088a3396902af2d4b5efb290">元组</h2>
<p>元组 (tuple) 看上去像列表的只读版本，但在底层实现上有很多不同之处。</p>
<ul>
<li>只读对象，元组和元素指针数组内存是一次性连续分配的。</li>
<li>虚拟机缓存 n 个元素数量小于 20 的元组复用对象。</li>
</ul>
<p>在编码中，应该尽可能用元组代替列表。除内存复用更高效外，其只读特征更利于并行开发。</p>
<p>基本操作：</p>
<pre><code>&gt;&gt;&gt; a = (4)     # 少了逗号，就成了普通的括号运算符了。
&gt;&gt;&gt; type(a)
&lt;type 'int'&gt;
&gt;&gt;&gt; a = (4,)    # 这才是元组。
&gt;&gt;&gt; type(a)
&lt;type 'tuple'&gt;
&gt;&gt;&gt; s = tuple("abcadef")   # 将其他序列类型转换成元组。
&gt;&gt;&gt; s
('a', 'b', 'c', 'a', 'd', 'e', 'f')
&gt;&gt;&gt; s.count("a")    # 元素统计。
2
&gt;&gt;&gt; s.index("d")    # 查找元素，返回序号。
4</code></pre>
<p>标准库另提供了特别的 namedtuple，可用名字访问元素项。</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; User = namedtuple("User", "name age") # 空格分隔字段名，或使用迭代器。
&gt;&gt;&gt; u = User("user1", 10)
&gt;&gt;&gt; u.name, u.age
('user1', 10)</code></pre>
<p>其实 namedtuple 并不是元组，而是利用模板动态创建的自定义类型。</p>
<h2 id="ad552573d71a78e98660beb1131cbdf8">字典</h2>
<p>字典 (dict) 采用开放地址法的哈希表实现。</p>
<ul>
<li>自带元素容量为 8 的 smalltable，只有 &quot;超出&quot; 时才到堆上额外分配元素表内存。</li>
<li>虚拟机缓存 80 个字典复用对象，但在堆上分配的元素表内存会被释放。</li>
<li>按需动态调整容量。扩容或收缩操作都将重新分配内存，重新哈希。</li>
<li>删除元素操作不会立即收缩内存。</li>
</ul>
<p>创建字典：</p>
<pre><code>&gt;&gt;&gt; {}      # 空字典
{}
&gt;&gt;&gt; {"a":1, "b":2}     # 普通构造方式
{'a': 1, 'b': 2}
&gt;&gt;&gt; dict(a = 1, b = 2)    # 构造
{'a': 1, 'b': 2}
&gt;&gt;&gt; dict((["a", 1], ["b", 2]))   # 用两个序列类型构造字典。
{'a': 1, 'b': 2}
&gt;&gt;&gt; dict(zip("ab", range(2)))   # 同上
{'a': 0, 'b': 1}
&gt;&gt;&gt; dict(map(None, "abc", range(2)))  # 同上
{'a': 0, 'c': None, 'b': 1}
&gt;&gt;&gt; dict.fromkeys("abc", 1)   # 用序列做 key，并提供默认 value。
{'a': 1, 'c': 1, 'b': 1}
&gt;&gt;&gt; {k:v for k, v in zip("abc", range(3))} # 使用生成表达式构造字典。
{'a': 0, 'c': 2, 'b': 1}</code></pre>
<p>基本操作：</p>
<pre><code>&gt;&gt;&gt; d = {"a":1, "b":2}
&gt;&gt;&gt; "b" in d     # 判断是否包含 key。
True
&gt;&gt;&gt; d = {"a":1, "b":2}
&gt;&gt;&gt; del d["b"]     # 删除 k/v。
&gt;&gt;&gt; d
{'a': 1}
&gt;&gt;&gt; d = {"a":1}
&gt;&gt;&gt; d.update({"c": 3})    # 合并 dict。
&gt;&gt;&gt; d
{'a': 1, 'c': 3}
&gt;&gt;&gt; d = {"a":1, "b":2}
&gt;&gt;&gt; d.pop("b")     # 弹出 value。
&gt;&gt;&gt; d
(2, {'a': 1})
&gt;&gt;&gt; d = {"a":1, "b":2}
&gt;&gt;&gt; d.popitem()     # 弹出 (key, value)。
('a', 1)</code></pre>
<p>默认返回值：</p>
<pre><code>&gt;&gt;&gt; d = {"a":1, "b":2}
&gt;&gt;&gt; d.get("c")     # 如果没有对应 key，返回 None。
None
&gt;&gt;&gt; d.get("d", 123)    # 如果没有对应 key，返回缺省值。
123
&gt;&gt;&gt; d.setdefault("a", 100)   # key 存在，直接返回 value。
1
&gt;&gt;&gt; d.setdefault("c", 200)    # key 不存在，先设置，后返回。
200
&gt;&gt;&gt; d
{'a': 1, 'c': 200, 'b': 2}</code></pre>
<p>迭代器操作：</p>
<pre><code>&gt;&gt;&gt; d = {"a":1, "b":2}
&gt;&gt;&gt; d.keys()
['a', 'b']
&gt;&gt;&gt; d.values()
[1, 2]
&gt;&gt;&gt; d.items()
[('a', 1), ('b', 2)]
&gt;&gt;&gt; for k in d: print k, d[k]
a 1
b 2
&gt;&gt;&gt; for k, v in d.items(): print k, v
a 1
b 2</code></pre>
<p>对于大字典，调用 keys()、values()、items() 会构造同样巨大的列表。建议用迭代器替代，以减少内存开销。</p>
<pre><code>&gt;&gt;&gt; d = {"a":1, "b":2}
&gt;&gt;&gt; d.iterkeys()
&lt;dictionary-keyiterator object at 0x10de82cb0&gt;
&gt;&gt;&gt; d.itervalues()
&lt;dictionary-valueiterator object at 0x10de82d08&gt;
&gt;&gt;&gt; d.iteritems()
&lt;dictionary-itemiterator object at 0x10de82d60&gt;
&gt;&gt;&gt; for k, v in d.iteritems():
... print k, v
a 1
b 2</code></pre>
<p><strong>视图</strong></p>
<p>要判断两个字典间的差异，使用视图是最简便的做法。</p>
<pre><code>&gt;&gt;&gt; d1 = dict(a = 1, b = 2)
&gt;&gt;&gt; d2 = dict(b = 2, c = 3)
&gt;&gt;&gt; d1 &amp; d2     # 字典不支持该操作。
TypeError: unsupported operand type(s) for &amp;: 'dict' and 'dict'
&gt;&gt;&gt; v1 = d1.viewitems()
&gt;&gt;&gt; v2 = d2.viewitems()
&gt;&gt;&gt; v1 &amp; v2     # 交集
set([('b', 2)])
&gt;&gt;&gt; v1 | v2     # 并集
set([('a', 1), ('b', 2), ('c', 3)])
&gt;&gt;&gt; v1 - v2     # 差集 (仅 v1 有，v2 没有的)
set([('a', 1)])
&gt;&gt;&gt; v1 ^ v2     # 对称差集 (不会同时出现在 v1 和 v2 中)
set([('a', 1), ('c', 3)])
&gt;&gt;&gt; ('a', 1) in v1    # 判断
True</code></pre>
<p>视图让某些操作变得更加简便，比如在不引入新数据项的情况下更新字典内容。</p>
<pre><code>&gt;&gt;&gt; a = dict(x=1)
&gt;&gt;&gt; b = dict(x=10, y=20)
&gt;&gt;&gt; a.update({k:b[k] for k in a.viewkeys() &amp; b.viewkeys()})
&gt;&gt;&gt; a
{'x': 10}</code></pre>
<p>视图会和字典同步变更。</p>
<pre><code>&gt;&gt;&gt; d = {"a": 1}
&gt;&gt;&gt; v = d.viewitems()
&gt;&gt;&gt; v
dict_items([('a', 1)])
&gt;&gt;&gt; d["b"] = 2
&gt;&gt;&gt; v
dict_items([('a', 1), ('b', 2)])
&gt;&gt;&gt; del d["a"]
&gt;&gt;&gt; v
dict_items([('b', 2)])</code></pre>
<p><strong>扩展</strong></p>
<p>当访问的 key 不存在时， defaultdict 自动调用 factory 对象创建所需键值对。factory 可以是任何无参数函数或 callable 对象。</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; d["a"].append(1) # key "a" 不存在，直接用 list() 函数创建一个空列表作为 value。
&gt;&gt;&gt; d["a"].append(2)
&gt;&gt;&gt; d["a"]
[1, 2]</code></pre>
<p>字典是哈希表，默认迭代是无序的。如果希望按照元素添加顺序输出结果，可以用 OrderedDict。</p>
<pre><code>&gt;&gt;&gt; from collections import OrderedDict
&gt;&gt;&gt; d = dict()
&gt;&gt;&gt; d["a"] = 1
&gt;&gt;&gt; d["b"] = 2
&gt;&gt;&gt; d["c"] = 3
&gt;&gt;&gt; for k, v in d.items(): print k, v  # 并非按添加顺序输出。
a 1
c 3
b 2
&gt;&gt;&gt; od = OrderedDict()
&gt;&gt;&gt; od["a"] = 1
&gt;&gt;&gt; od["b"] = 2
&gt;&gt;&gt; od["c"] = 3
&gt;&gt;&gt; for k, v in od.items(): print k, v  # 按添加顺序输出。
a 1
b 2
c 3
&gt;&gt;&gt; od.popitem()     # 按 LIFO 顺序弹出。
('c', 3)
&gt;&gt;&gt; od.popitem()
('b', 2)
&gt;&gt;&gt; od.popitem()
('a', 1)</code></pre>
<h2 id="508b37f195b91f7d901273d4cd2d87f0">集合</h2>
<p>集合 (set) 用来存储无序不重复对象。所谓不重复对象，除了不是同一对象外，还包括 &quot;值&quot; 不能相同。集合只能存储可哈希对象，一样有只读版本 frozenset。</p>
<pre><code>判重公式：(a is b) or (hash(a) == hash(b) and eq(a, b))</code></pre>
<p>在内部实现上，集合和字典非常相似，除了 Entry 没有 value 字段。集合不是序列类型，不能像列表那样按序号访问，也不能做切片操作。</p>
<pre><code>&gt;&gt;&gt; s = set("abc")     # 通过序列类型初始化。
&gt;&gt;&gt; s
set(['a', 'c', 'b'])
&gt;&gt;&gt; {v for v in "abc"}    # 通过构造表达式创建。
set(['a', 'c', 'b'])
&gt;&gt;&gt; "b" in s     # 判断元素是否在集合中。
True
&gt;&gt;&gt; s.add("d")     # 添加元素
&gt;&gt;&gt; s
set(['a', 'c', 'b', 'd'])
&gt;&gt;&gt; s.remove("b")     # 移除元素
&gt;&gt;&gt; s
set(['a', 'c', 'd'])
&gt;&gt;&gt; s.discard("a")     # 如果存在，就移除。
&gt;&gt;&gt; s
set(['c', 'd'])
&gt;&gt;&gt; s.update(set("abcd"))   # 合并集合
&gt;&gt;&gt; s
set(['a', 'c', 'b', 'd'])
&gt;&gt;&gt; s.pop()      # 弹出元素
'a'
&gt;&gt;&gt; s
set(['c', 'b', 'd'])</code></pre>
<p>集合和字典、列表最大的不同除了元素不重复外，还支持集合运算。</p>
<pre><code>&gt;&gt;&gt; "c" in set("abcd")    # 判断集合中是否有特定元素。
True
&gt;&gt;&gt; set("abc") is set("abc")
False
&gt;&gt;&gt; set("abc") == set("abc")   # 相等判断
True
&gt;&gt;&gt; set("abc") = set("abc")   # 不等判断
False
&gt;&gt;&gt; set("abcd") &gt;= set("ab")   # 超集判断 (issuperset)
True
&gt;&gt;&gt; set("bc") &lt; set("abcd")   # 子集判断 (issubset)
True
&gt;&gt;&gt; set("abcd") | set("cdef")   # 并集 (union)
set(['a', 'c', 'b', 'e', 'd', 'f'])
&gt;&gt;&gt; set("abcd") &amp; set("abx")   # 交集 (intersection)
set(['a', 'b'])
&gt;&gt;&gt; set("abcd") - set("ab")   # 差集 (difference)， 仅左边有，右边没有的。
set(['c', 'd'])    
&gt;&gt;&gt; set("abx") ^ set("aby")   # 对称差集 (symmetric_difference)
set(['y', 'x'])     # 不会同时出现在两个集合当中的元素。
&gt;&gt;&gt; set("abcd").isdisjoint("ab")  # 判断是否没有交集
False</code></pre>
<p>更新操作：</p>
<pre><code>&gt;&gt;&gt; s = set("abcd")
&gt;&gt;&gt; s |= set("cdef")    # 并集 (update)
&gt;&gt;&gt; s
set(['a', 'c', 'b', 'e', 'd', 'f'])
&gt;&gt;&gt; s = set("abcd")
&gt;&gt;&gt; s &amp;= set("cdef")    # 交集 (intersection_update)
&gt;&gt;&gt; s
set(['c', 'd'])
&gt;&gt;&gt; s = set("abx")
&gt;&gt;&gt; s -= set("abcdy")    # 差集 (difference_update)
&gt;&gt;&gt; s
set(['x'])   
&gt;&gt;&gt; s = set("abx")
&gt;&gt;&gt; s ^= set("aby")    # 对称差集 (symmetric_difference_update)
&gt;&gt;&gt; s
set(['y', 'x'])  </code></pre>
<p>集合和字典主键都必须是可哈希类型对象，但常用的 list、dict、set、defaultdict、OrderedDict 都是不可哈希的，仅有 tuple、frozenset 可用。</p>
<pre><code>&gt;&gt;&gt; hash([])
TypeError: unhashable type: 'list'
&gt;&gt;&gt; hash({})
TypeError: unhashable type: 'dict'
&gt;&gt;&gt; hash(set())
TypeError: unhashable type: 'set'
&gt;&gt;&gt; hash(tuple()), hash(frozenset())
(3527539, 133156838395276)</code></pre>
<p>如果想把自定义类型放入集合，需要保证 hash 和 equal 的结果都相同才能去重。</p>
<pre><code>&gt;&gt;&gt; class User(object):
...     def __init__(self, name):
...         self.name = name
&gt;&gt;&gt; hash(User("tom")) # 每次的哈希结果都不同
279218517
&gt;&gt;&gt; hash(User("tom"))
279218521
&gt;&gt;&gt; class User(object):
...     def __init__(self, name):
...         self.name = name
...
...     def __hash__(self):
...         return hash(self.name)
...
...     def __eq__(self, o):
...         if not o or not isinstance(o, User): return False
...         return self.name == o.name
&gt;&gt;&gt; s = set()
&gt;&gt;&gt; s.add(User("tom"))
&gt;&gt;&gt; s.add(User("tom"))
&gt;&gt;&gt; s
set([&lt;__main__.User object at 0x10a48d150&gt;])</code></pre>
<p>数据结构很重要，这几个内置类型并不足以完成全部工作。像 C、数据结构、常用算法这类基础是每个程序开发人员都应该掌握的。</p></div>
		<div class="previous-and-next">
						<span class="pull-left">上一篇: <a id="previous_link" href="basic-environment.html" data-toggle="tooltip" data-placement="top" title="上翻页快捷键：左方向键">基本环境</a></span>
			
						<span class="pull-right">下一篇: <a id="next_link" href="expression.html" data-toggle="tooltip" data-placement="top" title="下翻页快捷键：右方向键">表达式</a></span>
					</div>
				<div id="jkcomments"></div>
			</div>
	<div class="wiki-right fl">
		<div id="myScrollspy">
						<ul class="nav nav-tabs nav-stacked" data-spy="affix" data-offset-top="300">
							<li><a href="#55d4790c5d819cd0462cbe89561b0dd4">数字</a></li>
							<li><a href="#cc4dd1da7e1a754534215f02fb9ba85d">字符串</a></li>
							<li><a href="#3712972d84adf48acbd6ad24b4d75ad0">列表</a></li>
							<li><a href="#cda9f200088a3396902af2d4b5efb290">元组</a></li>
							<li><a href="#ad552573d71a78e98660beb1131cbdf8">字典</a></li>
							<li><a href="#508b37f195b91f7d901273d4cd2d87f0">集合</a></li>
						</ul>
					</div>
		<div class="backtotop">
			<a href="javascript:;" class="btn-backtotop" style="display: none;"><div class="arrow"></div><div class="stick"></div></a>
		</div>
	</div>
	<div style="clear:both;"></div>
</div>
</body>
</html>